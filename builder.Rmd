---
title: "Dataset Builder"
author: "Greg Macfarlane"
date: "1/20/2020"
output: html_document
---

```{r setup, include=FALSE, cache = FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(sf)
library(leaflet)
library(tidyverse)
library(tigris)
library(tidycensus)
```

This document provides a place for data manipulation and notes necessary to
construct the PopulationSim implementation in the WFRC model region.

## Geographies

PopulationSim allows to have controls at 
any definition provided in a crosswalk called `data/geo_cross_walk.csv`. We want
to have controls at the following levels: 
  - TAZ
  - block group
  - tract
  - PUMA
  
To make this file, we start with the TAZ Shapefile included in the WFRC
`_Inputs` folder (previously exported to `.geojson` for space and simplicity)

```{r taz}
(taz <- st_read("inputs/taz.geojson") %>% 
   filter(CO_FIPS > 0) # remove external stations
)
```

The only fields that are directly useful to us include the TAZ and County fields.
We therefore need to do a join to get the tract crosswalk. To do
this, we'll use the `tigris` library to get the tracts for the counties in 
question and then do a spatial join.

```{r crosswalk}
taz <- taz %>% 
  transmute(TAZID, CO_FIPS = sprintf("%03d", CO_FIPS), ST_FIPS = "49", 
            taz_area = st_area(.))

county_list <- unique(taz$CO_FIPS)

tr <- tracts(state = "49", county = county_list, class = "sf") %>%
  st_transform(4326) %>%
  transmute(GEOID, tr_area = st_area(.))
```

As the map below shows, there are places where the tracts and TAZ boundaries
do not line up perfectly. As a result, we need to discover places where the 
many-to-many intersections can be ignored.

```{r tazmap}
leaflet() %>%
  addProviderTiles(providers$Esri.WorldGrayCanvas) %>%
  addPolygons(data = crosswalk, group = "TAZ", color = "red") %>%
  addPolygons(data = tr, group = "Tract") %>%
  addLayersControl(overlayGroups = c("Tract", "TAZ"))
```


To do this, we calculate the intersections of the two layers, which
each have their areas pre-calculated. We then calculate the area of the
intersected polygon and try to determine if the overlap is negligiible. If there
is an overlap of less than 100 square meters we just drop it outright.

```{r intersection}
cw_tr <- st_intersection(crosswalk, tr) %>%
  mutate(intersect_area = st_area(.)) %>%
  filter(as.numeric(intersect_area) > 100)

cw_tr %>%
  group_by(TAZID) %>%
  arrange(intersect_area, .by_group = TRUE)

ggplot(cw_bg, aes(x = as.numeric(intersect_area))) + geom_histogram() + scale_x_log10()
```

There may be opportunities to refine this process further, but we'll go with it
for now. Let's append the tract / PUMA lookup from the Census bureau

```{r puma}
puma_tract <- read_csv("https://www2.census.gov/geo/docs/maps-data/data/rel/2010_Census_Tract_to_2010_PUMA.txt") %>%
  transmute(tract = str_c(STATEFP, COUNTYFP, TRACTCE), puma = PUMA5CE)

(crosswalk <- cw_tr  %>%
  transmute(TAZID, tract = GEOID,
            county = substr(GEOID, 1, 5)) %>%
  left_join(puma_tract, by = c("tract")) %>%
  st_set_geometry(NULL)  %>%
  as_tibble() %>%
  mutate(region = 1))

write_csv(crosswalk, "data/geo_cross_walk.csv")
```

## Controls

Attributes we want to control for include:
 - Number of households
 - Household size
 - Household income
 - Age of persons
 - Household workers
 - Person worker status

### TAZ-level controls

The only TAZ-level control we get from WFRC is the number of households in each
TAZ. Therefore, this will be the only control in this file. The MAG data is only
available for 2020, so that's what we will be using even if 2017 or 2018 might
be more appropriate.

```{r taz_control}
tcf <- str_c("inputs/", dir("inputs/"))
taz_control <- lapply(tcf[grepl("SE_", tcf)], function(csv) {
  read_csv(csv) %>% select(TAZID, TOTHH)
}) %>%
  bind_rows()

write_csv(taz_control, "data/control_totals_taz.csv")
```


### Tract-Level Controls
The attributes available from the ACS include the following:
  - Household size, derived from Table `B08202: HOUSEHOLD SIZE BY NUMBER OF WORKERS IN HOUSEHOLD`
  - Household workers, derived from the same table
  - Age, derived from Table `B01001: SEX BY AGE`
  - Income, derived from Table `B19001:HOUSEHOLD INCOME IN THE PAST 12 MONTHS (IN 2018 INFLATION-ADJUSTED DOLLARS)` 

First, we can collect a unique list of all the tracts we want to get controls for,
alongside a complete list of all ACS variables
```{r tracts}
mytracts <- unique(crosswalk$tract)
acsvars <- load_variables(2018, "acs5", cache = TRUE)
```

#### Household size and workers
Because these two values come in the same table, we will build them together.

```{r sizework}
swvars <- str_c("B08202_", sprintf("%03d", c(2:5, 6, 9, 13, 18)))
raw_sw <- get_acs("tract", variables = swvars, state = "UT", county = county_list)

size_work <- raw_sw %>% 
  left_join(acsvars, by = c("variable" = "name")) %>%
  separate(label, c("VAR", "total", "label"), sep = "!!") %>%
  select(GEOID, label, estimate) 

works <- size_work %>%
  filter(grepl("work", label)) %>%
  mutate(
    num_work = str_extract(label, "\\d+"),
    workcat = case_when(
      num_work == 1 ~ "HHWORK1",
      num_work == 2 ~ "HHWORK2",
      num_work == 3 ~ "HHWORK3",
      TRUE ~ "HHWORK0"
    )
  ) %>% 
  group_by(GEOID, workcat) %>% summarize(count = sum(estimate))

sizes <- size_work %>%
  filter(!grepl("work", label)) %>%
  mutate(
   num_size = str_extract(label, "\\d+"),
   sizecat = str_c("HHSIZE", num_size) 
  ) %>%
  group_by(GEOID, sizecat) %>% summarize(count = sum(estimate))
```


#### Age
First we get the number of people of each age category.

```{r age}
agevars <- str_c("B01001_", sprintf("%03d", c(3:25, 27:49)))
raw_ages <- get_acs("tract", variables = agevars, state = "UT", county = county_list)
  
ages <- raw_ages %>%
  left_join(acsvars, by = c("variable" = "name")) %>%
  separate(label, c("VAR", "total", "sex", "age"), sep = "!!") %>%
  select(GEOID, sex, age, estimate)  %>%
  
  # regroup age categories
  mutate(
    numage = as.numeric(substr(age, 1, 2)),
    agecat = case_when(
      numage %in% c(15:24) ~ "HHAGE1",
      numage %in% c(25:54) ~ "HHAGE2",
      numage %in% c(55:64) ~ "HHAGE3",
      numage %in% c(65:99) ~ "HHAGE4",
      TRUE ~ "HHAGE0" # children less than 15 not categorized in demo
    )
  ) %>%
  
  # consolidate men and women
  group_by(GEOID, agecat) %>%
  summarise(count = sum(estimate))
```

#### Income

```{r income}
incvars <- str_c("B19001_", sprintf("%03d", c(2:17)))
raw_incs <- get_acs("tract", variables = incvars, state = "UT", county = county_list)

incs <- raw_incs %>%
  left_join(acsvars, by = c("variable" = "name")) %>%
  separate(label, c("VAR", "total", "income"), sep = "!!") %>%
  select(GEOID, income, estimate)  %>%
  # regroup income categories
  mutate(
    numinc  = stringr::str_extract(income, "\\d+"),
    inccat = case_when(
      numinc <  15 ~ "HHINC1",
      numinc <  30 ~ "HHINC2",
      numinc <  60 ~ "HHINC3",
      numinc >= 60 ~ "HHINC4",
      TRUE ~ as.character(NA)
    )
  ) %>%
  group_by(GEOID, inccat) %>%
  summarise(count = sum(estimate))
```


#### Tract Controls File
Now, we write out the tract controls file.
```{r tract_controls}
(tract_controls <- tibble(TRACT = mytracts) %>%
   left_join(ages  %>% spread(agecat,  count), by = c("TRACT" = "GEOID")) %>%
   left_join(incs  %>% spread(inccat,  count), by = c("TRACT" = "GEOID")) %>%
   left_join(works %>% spread(workcat, count), by = c("TRACT" = "GEOID")) %>%
   left_join(sizes %>% spread(sizecat, count), by = c("TRACT" = "GEOID"))
)

write_csv(tract_controls, "data/control_totals_tract.csv")
```


### PUMS Seed Data

The uncompressed seed data is too large to commit, so we have committed compressed
versions of the original files. 


