---
title: "Dataset Builder"
author: "Greg Macfarlane"
date: "1/20/2020"
output: html_document
---

```{r setup, include=FALSE, cache = FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(sf)
library(leaflet)
library(tidyverse)
library(tigris)
library(tidycensus)
```

This document provides a place for data manipulation and notes necessary to
construct the PopulationSim implementation in the WFRC model region.

## Geographic Cross-walk

PopulationSim allows to have controls at any definition provided in a crosswalk
called `data/geo_cross_walk.csv`. We want to have controls at the following
levels:

  - block group
  - tract
  - PUMA

In addition to this, we need to include the TAZ on the synthetic population so we
can apply the skims in ActivitySim. To build this file, we will do the following:

  - Begin with the TAZ shapefile
  - Collect a list of block groups population centroids from the Census TIGER
  database
  - Determine which TAZ each block group centroid is located in.
  - If there are TAZ that do not contain a block group centroid, we will divide
  the blocks spatially and remap.
    

To make this file, we start with the TAZ Shapefile included in the WFRC
`_Inputs` folder (previously exported to `.geojson` for space and simplicity)

```{r taz}
(taz <- st_read("inputs/taz.geojson") %>% 
   # remove external stations
   filter(CO_FIPS > 0)  %>%
   # TODO: remove filter to provo/orem
   filter(TAZID > 2200, TAZID < 2500) %>%
   # only keep TAZID and county
   transmute(TAZID, CO_FIPS = sprintf("%03d", CO_FIPS), ST_FIPS = "49", 
             taz_area = st_area(.))
)
```

Now, we want to get a list of the population-weighted centroid for each block
group.

```{r crosswalk}
bg_centroids <- read_csv(
  "https://www2.census.gov/geo/docs/reference/cenpop2010/blkgrp/CenPop2010_Mean_BG49.txt",
  col_types = list(STATEFP = col_character(), BLKGRPCE = col_character())
) %>%
  # filter to TAZ region
  filter(COUNTYFP %in% taz$CO_FIPS) %>%
  transmute(GEOID = str_c(STATEFP, COUNTYFP, TRACTCE, BLKGRPCE), LATITUDE, LONGITUDE) %>%
  st_as_sf(coords = c("LONGITUDE", "LATITUDE"), crs = 4326)
```

The map below suggests that will need some kind of control at the TAZ level. 
The only one we have available to us is the number of households, but that's 
probably okay.

```{r tazmap}
leaflet() %>%
  addProviderTiles(providers$Esri.WorldGrayCanvas) %>%
  addPolygons(data = taz, group = "TAZ", color = "red") %>%
  addCircleMarkers(data = bg_centroids, group = "bg") %>%
  addLayersControl(overlayGroups = c("BG", "TAZ"))
```
 
As a result, we need to calculate the spatial intersection of the TAZ and Block Groups
layers. This generates many sliver polygons, which we remove by simply asserting 
that an area has to have an area larger than 500 square meters. Beyond this, we check
that all TAZ are represented.

```{r intersection}
bg <- block_groups("UT", county = unique(taz$CO_FIPS), class = "sf") %>%
  st_transform(4326) %>%
  transmute(GEOID, bg_area = st_area(.))

# This generates lots of sliver and point and line intersections
cw_bg <- st_intersection(taz, bg) 

# so we filter out all of the points and linestrings
cw_polygons  <- cw_bg %>% filter(st_is(., "POLYGON"))
cw_mpolygons <- cw_bg %>% filter(st_is(., "MULTIPOLYGON"))
cw_geomcolls <- cw_bg %>% filter(st_is(., "GEOMETRYCOLLECTION")) %>%
  st_cast(.) %>% filter(st_is(., "POLYGON"))

# Add them back into a single dataframe, remove areas less than 500 m2
# TODO: when we add full region, put the geomcolls back in.
cw_bg_clean <- rbind(cw_polygons, cw_mpolygons) %>%
  mutate(intersect_area = as.numeric(st_area(.))) %>%
  filter(intersect_area > 500)
```

The resulting intersection file is pretty complex; we've gone from `r nrow(taz)` 
TAZs to `r nrow(cw_bg_clean)` objects in the crosswalk, but that will be fine for
now.

```{r cw_bg_map}
leaflet(cw_bg_clean) %>%
  addProviderTiles(providers$Esri.WorldGrayCanvas) %>%
  addPolygons()
```

There may be opportunities to refine this process further, but we'll go with it
for now. Let's append the tract / PUMA lookup from the Census bureau

```{r puma}
puma_tract <- read_csv("https://www2.census.gov/geo/docs/maps-data/data/rel/2010_Census_Tract_to_2010_PUMA.txt") %>%
  transmute(TRACT = str_c(STATEFP, COUNTYFP, TRACTCE), PUMA = PUMA5CE)

(crosswalk <- cw_bg_clean  %>%
  transmute(TAZ = TAZID, 
            BLOCKGROUP = GEOID, 
            TRACT = substr(GEOID, 1, 11),
            COUNTY = substr(GEOID, 1, 5)) %>%
  left_join(puma_tract, by = c("TRACT")) %>%
  st_set_geometry(NULL)  %>%
  as_tibble() %>%
  mutate(REGION = 1))

write_csv(crosswalk, "data/geo_cross_walk.csv")
```

## Controls

Attributes we want to control for include:
 - Number of households
 - Household size
 - Household income
 - Age of persons
 - Household workers
 - Person worker status

### TAZ-level controls

The only TAZ-level control we get from WFRC is the number of households in each
TAZ. Therefore, this will be the only control in this file. The MAG data is only
available for 2020, so that's what we will be using even if 2017 or 2018 might
be more appropriate.

```{r taz_control}
tcf <- str_c("inputs/", dir("inputs/"))
taz_control <- lapply(tcf[grepl("SE_", tcf)], function(csv) {
  read_csv(csv) %>% select(TAZ = TAZID, TOTHH)
}) %>%
  bind_rows() %>%
  filter(TAZ %in% crosswalk$TAZ)
names(taz_control)[names(taz_control) == 'TOTHH'] <- 'HHBASE'
write_csv(taz_control, "data/control_totals_taz.csv")
```


### Tract-Level Controls
The attributes available from the ACS include the following:
  - Household size, derived from Table `B08202: HOUSEHOLD SIZE BY NUMBER OF WORKERS IN HOUSEHOLD`
  - Household workers, derived from the same table
  - Age, derived from Table `B01001: SEX BY AGE`
  - Income, derived from Table `B19001:HOUSEHOLD INCOME IN THE PAST 12 MONTHS (IN 2018 INFLATION-ADJUSTED DOLLARS)` 

First, we can collect a unique list of all the tracts we want to get controls for,
alongside a complete list of all ACS variables
```{r tracts}
mytracts <- unique(crosswalk$TRACT)
mycounties <- unique(substr(crosswalk$COUNTY, 3, 5))
acsvars <- load_variables(2018, "acs5", cache = TRUE)
```

#### Household size and workers
Because these two values come in the same table, we will build them together.

```{r sizework}
swvars <- str_c("B08202_", sprintf("%03d", c(2:5, 6, 9, 13, 18)))
raw_sw <- get_acs("tract", variables = swvars, state = "UT", county = mycounties)

size_work <- raw_sw %>% 
  left_join(acsvars, by = c("variable" = "name")) %>%
  separate(label, c("VAR", "total", "label"), sep = "!!") %>%
  select(GEOID, label, estimate) 

works <- size_work %>%
  filter(grepl("work", label)) %>%
  mutate(
    num_work = str_extract(label, "\\d+"),
    workcat = case_when(
      num_work == 1 ~ "HHWORK1",
      num_work == 2 ~ "HHWORK2",
      num_work == 3 ~ "HHWORK3",
      TRUE ~ "HHWORK0"
    )
  ) %>% 
  group_by(GEOID, workcat) %>% summarize(count = sum(estimate))

sizes <- size_work %>%
  filter(!grepl("work", label)) %>%
  mutate(
   num_size = str_extract(label, "\\d+"),
   sizecat = str_c("HHSIZE", num_size) 
  ) %>%
  group_by(GEOID, sizecat) %>% summarize(count = sum(estimate))
```


#### Age
First we get the number of people of each age category.

```{r age}
agevars <- str_c("B01001_", sprintf("%03d", c(3:25, 27:49)))
raw_ages <- get_acs("tract", variables = agevars, state = "UT", county = mycounties)
  
ages <- raw_ages %>%
  left_join(acsvars, by = c("variable" = "name")) %>%
  separate(label, c("VAR", "total", "sex", "age"), sep = "!!") %>%
  select(GEOID, sex, age, estimate)  %>%
  
  # regroup age categories
  mutate(
    numage = as.numeric(substr(age, 1, 2)),
    agecat = case_when(
      numage %in% c(15:24) ~ "PAGE1",
      numage %in% c(25:54) ~ "PAGE2",
      numage %in% c(55:64) ~ "PAGE3",
      numage %in% c(65:99) ~ "PAGE4",
      TRUE ~ "PAGE0" # children less than 15 not categorized in demo
    )
  ) %>%
  
  # consolidate men and women
  group_by(GEOID, agecat) %>%
  summarise(count = sum(estimate))
```

#### Income

```{r income}
incvars <- str_c("B19001_", sprintf("%03d", c(2:17)))
raw_incs <- get_acs("tract", variables = incvars, state = "UT", county = mycounties)

incs <- raw_incs %>%
  left_join(acsvars, by = c("variable" = "name")) %>%
  separate(label, c("VAR", "total", "income"), sep = "!!") %>%
  select(GEOID, income, estimate)  %>%
  # regroup income categories
  mutate(
    numinc  = stringr::str_extract(income, "\\d+"),
    inccat = case_when(
      numinc <  15 ~ "HHINC1",
      numinc <  30 ~ "HHINC2",
      numinc <  60 ~ "HHINC3",
      numinc >= 60 ~ "HHINC4",
      TRUE ~ as.character(NA)
    )
  ) %>%
  group_by(GEOID, inccat) %>%
  summarise(count = sum(estimate))
```


#### Number of Households

We will put the number of households at the tract on the controls data frame, but
we will not use it at this point.
```{r hhtotal}
raw_hh <- get_acs("tract", variables = "B08202_001", state = "UT", county = mycounties)

hh <- raw_hh %>%
  select(GEOID, HHBASE = estimate) 

```


#### Tract Controls File
Now, we write out the tract controls file.
```{r tract_controls}
(tract_controls <- tibble(TRACT = mytracts) %>%
   left_join(ages  %>% spread(agecat,  count), by = c("TRACT" = "GEOID")) %>%
   left_join(incs  %>% spread(inccat,  count), by = c("TRACT" = "GEOID")) %>%
   left_join(works %>% spread(workcat, count), by = c("TRACT" = "GEOID")) %>%
   left_join(sizes %>% spread(sizecat, count), by = c("TRACT" = "GEOID")) %>% 
   left_join(hh, by = c("TRACT" = "GEOID")) 
)

write_csv(tract_controls, "data/control_totals_tract.csv")
```


### PUMS Seed Data

The uncompressed seed data is too large to commit, so we have committed compressed
versions of the original files. 

We need to clean and re-save the PUMS seed data files for households and for people.
```{r pums_hh}
pums_hh <- read_csv("inputs/psam_h49.csv.zip", 
                    col_types = list(SERIALNO = col_character(),
                                     NP = col_integer(),
                                     FINCP = col_number(),
                                     ADJINC = col_number()))

seed_hh <- pums_hh %>%
  mutate(hh_id = 1:nrow(.)) %>%
  filter(NP > 0) %>%
  mutate(HHINCADJ = FINCP * ADJINC)

replace_na <- function(x) {
  ifelse(is.na(x),-8,x)
}

clean_hh <- seed_hh %>% 
  transform(HHINCADJ = as.numeric(HINCP) * as.numeric(ADJINC)/1000000) %>% 
  mutate_at(.vars = vars(NP, WIF, WGTP, HHINCADJ), replace_na)

write_csv(clean_hh, "data/seed_households.csv")
```

```{r pums_persons}
pums_persons <- read_csv("inputs/psam_p49.csv.zip",
                         col_types = list(SERIALNO = col_character())
                         )

seed_per <- pums_persons %>%
  left_join(seed_hh %>% select(SERIALNO, hh_id))

clean_per <- seed_per %>% 
  transform(WGTP = as.numeric(PWGTP)) %>% 
  mutate_at(.vars = vars(WGTP, AGEP), replace_na)

persons_hhid <- clean_per
left_join(persons_hhid, clean_hh, by = SERIALNO)

write_csv(clean_per, "data/seed_persons.csv")
```

#### Remove NA fields from seed files
Replace NA fields with a negative integer to avoid errors
```{r remove_na}
replace_na <- function(x) {
  ifelse(is.na(x),-8,x)
}

clean_hh <- read.csv("data/seed_households.csv") %>% 
  mutate_all(replace_na) %>% 
  write_csv("data/seed_households.csv")

clean_per <- read.csv("data/seed_persons.csv") %>% 
  mutate_all(replace_na) %>% 
  write_csv("data/seed_persons.csv")
```

### Meta Controls
PopulationSim requires (we think) at least some region-level controls. We will
simply sum up the total households in the controls data to work with this.

```{r meta}
(meta <- tract_controls %>%
  summarise(REGION = 1,
            totalPOP = sum(PAGE0) +  sum(PAGE1) +  sum(PAGE2) +  sum(PAGE3) +  sum(PAGE4)))
write_csv(meta, "data/control_totals_meta.csv")
```




